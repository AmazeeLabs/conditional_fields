<?php

/* TODO: Grouping
define('CONDITIONAL_FIELDS_GROUPING_AND', 0);
define('CONDITIONAL_FIELDS_GROUPING_OR',  1);
define('CONDITIONAL_FIELDS_GROUPING_XOR', 2);
*/

define('CONDITIONAL_FIELDS_ELEMENT_VIEW_NOTHING',  0);
define('CONDITIONAL_FIELDS_ELEMENT_VIEW_EVALUATE', 1);

/**
 * Implementationation of hook_menu().
 */
function conditional_fields_menu() {
  $items = array();

  $items['admin/structure/dependencies'] = array(
    'title' => 'Dependencies',
    'description' =>  'Administer field dependencies for the site.',
    'page callback' => 'conditional_fields_admin_settings',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/conditional_fields.admin.inc',
  );

  $bundles = field_info_bundles();

  foreach ($bundles as $entity_type => $bundle) {
    foreach ($bundle as $bundle_name => $bundle_info) {
      $items["admin/structure/dependencies/add/$entity_type/$bundle_name"] = array(
        'title' => 'Add dependency',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('conditional_fields_dependency_add_form', 4, 5),
        'access arguments' => array('administer site configuration'),
        'file' => 'includes/conditional_fields.admin.inc',
      );
    }
  }

  $items['admin/structure/dependencies/edit/%'] = array(
    'title' => 'Edit dependency',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('conditional_fields_dependency_edit_form', 4),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/conditional_fields.admin.inc',
  );

  $items['admin/structure/dependencies/delete/%'] = array(
    'title' => 'Delete dependency',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('conditional_fields_dependency_delete_form', 4),
    'access arguments' => array('administer site configuration'),
    'file' => 'includes/conditional_fields.admin.inc',
  );

  return $items;
}

/**
 * Load all dependencies from the database.
 * You may filter ther result providing an entity type and/or a bundle name.  
 */
function conditional_fields_load_dependencies($entity_type = '', $bundle = '') {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $dependencies;
  if (!isset($dependencies)) {
    $dependencies = &drupal_static(__FUNCTION__);
  }

  if (!$dependencies) {
    $dependencies = array();
  }

  if (!isset($dependencies[$entity_type][$bundle])) {
    $select = db_select('conditional_fields', 'cf');
    $select->join('field_config_instance', 'fci_dependee', 'cf.dependee = fci_dependee.id');
    $select->join('field_config_instance', 'fci_dependent', 'cf.dependent = fci_dependent.id');
    $select->fields('cf', array('id', 'options'));  
    $select->addField('fci_dependee', 'field_name', 'dependee');
    $select->addField('fci_dependent', 'field_name', 'dependent');
    $select->addField('fci_dependee', 'entity_type');
    $select->addField('fci_dependee', 'bundle');

    if ($entity_type) {
      $select->condition(db_and()->condition('fci_dependee.entity_type', $entity_type)->condition('fci_dependent.entity_type', $entity_type));
    }

    if ($bundle) {
      $select->condition(db_and()->condition('fci_dependee.bundle', $bundle)->condition('fci_dependent.bundle', $bundle));
    }

    $result = $select->execute();

    foreach ($result as $dependency) {
      $entity_type ? $result_entity_type = $entity_type : $result_entity_type = $dependency->entity_type;
      $bundle ? $result_bundle = $bundle : $result_bundle = $dependency->bundle;

      $dependencies[$result_entity_type][$result_bundle][$dependency->dependee]['dependents'][$dependency->dependent] = $dependencies[$result_entity_type][$result_bundle][$dependency->dependent]['dependees'][$dependency->dependee] = array(
        'id' => $dependency->id,
        'options' => unserialize($dependency->options),
      );
    }
  }

  if ($entity_type && $bundle) {
    return $dependencies[$entity_type][$bundle];
  }
  else {
    return $dependencies;
  }
}

/**
 * Load a dependency by id of the fields, entity type and bundle name
 */
function conditional_fields_dependency_load($dependee_id, $dependent_id, $entity_type, $bundle) {
  $select = db_select('conditional_fields', 'cf');
  $select->fields('cf', array('id', 'dependee', 'dependent', 'options'));

  $select->join('field_config_instance', 'fci_dependee', 'cf.dependee = fci_dependee.id');
  $select->join('field_config_instance', 'fci_dependent', 'cf.dependent = fci_dependent.id');
  $select->condition(db_and()->condition('fci_dependee.bundle', $bundle)->condition('fci_dependent.bundle', $bundle));
  $select->condition(db_and()->condition('fci_dependee.entity_type', $entity_type)->condition('fci_dependent.entity_type', $entity_type));

  $select->condition(db_and()->condition('fci_dependee.id', $dependee_id)->condition('fci_dependent.id', $dependent_id));

  $result = $select->execute()->fetchAssoc();

  if (isset($result['options'])) {
    $result['options'] = unserialize($result['options']);
  }
  return $result;
}

/**
 * Load a dependency from the database by id
 */
function conditional_fields_dependency_load_by_id($id) {
  $result = db_select('conditional_fields', 'cf')
    ->fields('cf', array('id', 'dependee', 'dependent', 'options'))
    ->condition('id', $id)
    ->execute()
    ->fetchAssoc();

  if (isset($result['options'])) {
    $result['options'] = unserialize($result['options']);
  }

  return $result;
}

/**
 * Insert a new dependency in the database
 * For the format of $options, @see conditional_fields_dependency_default_options()
 */
function conditional_fields_dependency_insert($dependee_id, $dependent_id, $options = NULL) {
  if (!$options) {
    $options = conditional_fields_dependency_default_options();
  }

  return db_insert('conditional_fields')
    ->fields(array(
      'dependee'  => $dependee_id,
      'dependent' => $dependent_id,
      'options'   => serialize($options),
    ))
    ->execute();
}

/**
 * Update a dependency  
 */
function conditional_fields_dependency_update($dependency) {
  return db_update('conditional_fields')
    ->fields(array(
      'dependee'  => $dependency['dependee'],
      'dependent' => $dependency['dependent'],
      'options'   => serialize($dependency['options']),
    ))
    ->condition('id', $dependency['id'])
    ->execute();
}

/**
 * Delete dependencies
 */
function conditional_fields_dependency_delete($dependency_ids) {
  $or = db_or();
  foreach ($dependency_ids as $id) {
    $or = $or->condition('id', $id); // TODO: test
  }
  return db_delete('conditional_fields')
    ->condition($or)
    ->execute();
}

/**
 * Provide default options for a dependency
 */
function conditional_fields_dependency_default_options() {
  return array(
    'selector'              => '', // A default value is built later using conditional_fields_field_selector()
    'selector_custom'       => 0,
    'state'                 => 'visible', // See conditional_fields_states() for available values
    'condition'             => 'value', // See conditional_fields_conditions() for available conditions
    'value'                 => 'conditional_fields_dependency_value_any',
    'values_set'            => array(),
    // TODO 'grouping'      => CONDITIONAL_FIELDS_GROUPING_AND,
    // TODO 'effect'        => 0,
    'element_view'          => CONDITIONAL_FIELDS_ELEMENT_VIEW_EVALUATE,
    'element_view_per_role' => 0,    
  );
}

/**
 * Implements hook_field_attach_form().
 *
 * Add states information to the fields.
 */
function conditional_fields_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  if (!$dependencies = conditional_fields_load_dependencies($entity_type, $form['#bundle'])) {
    return;
  }

  foreach ($dependencies as $field_name => $dependency) {
    if (!isset($form[$field_name]) || !isset($dependency['dependees'])) { // TODO: check in groups...
      continue;
    }

    foreach ($dependency['dependees'] as $dependee => $data) {
      $state = $data['options']['state'];

      // Build the values that trigger the condition
      $values = array();

      if ($data['options']['condition'] != 'value') {
        $values[$data['options']['condition']] = TRUE;
      }
      else {
        switch ($data['options']['value']) {
          case 'conditional_fields_dependency_value_all':
            $values['value'] = $data['options']['values_set'];
            break;
          case 'conditional_fields_dependency_value_none':
            $state = '!' . $state;
          case 'conditional_fields_dependency_value_any':
            foreach ($data['options']['values_set'] as $value) {
              $values[] = array('value' => $value);
            }
            break;
          default:
            // It's a single allowed value
            $values['value'] = $data['options']['value'];
            break;
        }
      }

      // #states should be applied to the field itself, not one of its containers...
      // For now, we need an ugly solution: field handling based on widget type
      // TODO: Find a better way to obtain the structure of these fields with no hard coding...
      $widget_type = $form_state['field'][$field_name][$form[$field_name]['#language']]['instance']['widget']['type'];
      $structure = conditional_fields_field_structure($widget_type, $form[$field_name]);

      // Build the #states array
      $states_array = array_merge($structure, array('#states', $state, $data['options']['selector']));
      drupal_array_set_nested_value($form[$field_name], $states_array, $values);      
    }
  }
}

/**
 * Darn fields.
 *
 * TODO: pass to using hook_extract_form_values / field_default_extract_form_values if possible?
 */
function conditional_fields_field_structure($widget_type, $form_field) {
  switch ($widget_type) {
    case 'options_buttons':
    case 'options_select':
      $structure = array($form_field['#language']);
      break;
    case 'file_generic':
    case 'image_image':
      $structure = array();
      break;
    default :
      // By default, we assume that a field is located at [language][cardinality][column[0]]
      $structure = array($form_field['#language'], 0, $form_field[$form_field['#language']][0]['#columns'][0]);
  }

  // Allow other modules to provide a custom structure
  $context = array('widget_type' => $widget_type, 'form_field' => $form_field);
  drupal_alter('conditional_fields_field_structure', $structure, $context);

  return $structure;
}

/**
 * Builds a jQuery selector for a field
 * The selector will have this structure:
 * [name="FIELD_NAME[LANGUAGE][DELTA][COLUMN]"] 
 *
 * @param (String)
 *   $widget_type
 *
 * @param (Array)
 *   $field
 *   
 * @return (String)
 *   
 */
function conditional_fields_field_selector($field_name, $widget_type, $field) {
  // The selector for checkboxes and radios must be more generic
  $widget_type == 'options_buttons' ? $selector = '[name^="' : $selector = '[name="';

  return $selector . $field_name . '[' . implode('][', conditional_fields_field_structure($widget_type, $field)) . ']"]';
}

/**
 * Implements hook_field_access()
 *
 * We remove access to dependent fields with a "value" condition whose dependees have a different value.
 */
function conditional_fields_field_access($op, $field, $entity_type, $entity, $account) {
  if ($op == 'view') {
    $dependencies = conditional_fields_load_dependencies($entity_type); // TODO: bundle name?

    // Verify if this field is a dependee
    $this_dependent = isset($dependencies[$field['field_name']]['dependees']) ? $dependencies[$field['field_name']] : FALSE;

    if ($this_dependent) {
      foreach ($this_dependent['dependees'] as $dependee_name => $data) {
        // We can interface with the States API only through the Value condition,
        // since other conditions are purely presentational
        if ($data['options']['condition'] == 'value') {
          // Build an array of values
          // Works only with first column for now (usually 'value')
          $column = array_shift(array_keys($field['columns']));

          $values = array();
          
          if (!empty($entity->{$dependee_name})) {
            foreach ($entity->{$dependee_name}[$entity->language] as $value) {
              $values[] = $value[$column];
            }
          }

          switch ($data['options']['value']) {
            case 'conditional_fields_dependency_value_all':
              $values_diff = array_diff($data['options']['values_set'], $values);
              if (!empty($values_diff)) {
                return FALSE;
              }
              break;
            case 'conditional_fields_dependency_value_any':
              $values_intersect = array_intersect($data['options']['values_set'], $values);
              if (empty($values_intersect)) {
                return FALSE;
              }
              break;
            case 'conditional_fields_dependency_value_none':
              $values_intersect = array_intersect($data['options']['values_set'], $values);
              if (!empty($values_intersect)) {
                return FALSE;
              }
              break;

            default:
              // Single allowed value
              if (count($values) > 1 || $values[0][$column] != $data['options']['value']) {
                return FALSE;
              }
          }
        }
      }
    }
  }
}

/**
 * Entity types have no human readable names. We provide some for the entity types in core.
 */
function conditional_fields_entities_names() {
  return array(
    'comment'             => t('Comments'),
    'node'                => t('Content types'),
    'file'                => t('Files'),
    'taxonomy_term'       => t('Terms'),
    'taxonomy_vocabulary' => t('Vocabularies'),
    'user'                => t('Users'),
  );
}

/**
 * List of supported states that may be applied to a dependent field.
 *   
 * @return (Array)
 *   
 */
function conditional_fields_states() {
  $states = array(
    // Supported by States API
    'enabled'    => t('Enabled'),
    'disabled'   => t('Disabled'),
    'visible'    => t('Visible'),
    'invisible'  => t('Invisible'),
    'checked'    => t('Checked'),
    'unchecked'  => t('Unchecked'),
    'expanded'   => t('Expanded'),
    'collapsed'  => t('Collapsed'),
    // Supported by Conditional Fields (TODO)
    /*
    'required'   => t('Required'),
    'optional'   => t('Optional'),
    'relevant'   => t('Relevant'),
    'irrelevant' => t('Irrelevant'),
    'valid'      => t('Valid'),
    'invalid'    => t('Invalid'),
    'touched'    => t('Touched'),
    'untouched'  => t('Untouched'),
    'filled'     => t('Filled'),
    'empty'      => t('Empty'),
    'readwrite'  => t('Read/Write'),
    'readonly'   => t('Read Only'),
    */
  );

  // Allow other modules to modify the states
  drupal_alter('conditional_fields_states', $states);

  return $states;
}

/**
 * List of states of a dependee field that may be used to evaluate a condition.
 *
 * @param (Bool)
 *   $checkbox
 *
 * @return (Array)
 *   
 */
function conditional_fields_conditions($options_buttons = FALSE) {
  // Supported by States API
  $conditions = array(
    'enabled'    => t('Enabled'),
    'disabled'   => t('Disabled'),
    'visible'    => t('Visible'),
    'invisible'  => t('Invisible'),
  );

  // Relevant only if dependee is a checkbox or list of checkboxes/radios
  if ($options_buttons) {
    $conditions['checked'] = t('Checked');
    $conditions['unchecked'] = t('Unchecked');
  }

  // Value stays at bottom for more intuitive UI
  $conditions['value'] = t('Value');

  // TODO: Add support from Conditional Fields to these conditions
  /*
  'required'   => t('Required'),
  'optional'   => t('Optional'),
  'relevant'   => t('Relevant'),
  'irrelevant' => t('Irrelevant'),
  'valid'      => t('Valid'),
  'invalid'    => t('Invalid'),
  'touched'    => t('Touched'),
  'untouched'  => t('Untouched'),
  'filled'     => t('Filled'),
  'empty'      => t('Empty'),
  'readwrite'  => t('Read/Write'),
  'readonly'   => t('Read Only'),
  */

  // Allow other modules to modify the conditions
  drupal_alter('conditional_fields_conditions', $conditions);

  return $conditions;
}

/**
 * Implements hook_js_alter().
 *
 * Overrides core states API with an updated version that allows multiple conditions and OR/XOR logic.
 * Ongoing development here: http://drupal.org/node/735528
 */
function conditional_fields_js_alter(&$javascript) {
  if (isset($javascript['misc/states.js'])) {
    $javascript['misc/states.js']['data'] = drupal_get_path('module', 'conditional_fields') . '/js/states.js';
  }
}
